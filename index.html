<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Discord Emoji Ultimate</title>
    <link href="https://fonts.googleapis.com/css2?family=M+PLUS+2:wght@900&family=Noto+Sans+JP:wght@900&family=Reggae+One&family=RocknRoll+One&family=Dela+Gothic+One&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #1e1f22; --panel: #2b2d31; --card: #313338;
            --accent: #5865f2; --success: #248046; --danger: #ed4245; 
            --text: #f2f3f5; --muted: #b5bac1; --border: #111;
        }
        body {
            font-family: 'Noto Sans JP', sans-serif; background: var(--bg); color: var(--text);
            margin: 0; display: flex; height: 100vh; overflow: hidden; font-size: 13px;
        }

        /* å·¦ã‚µã‚¤ãƒ‰ãƒãƒ¼ (æ“ä½œãƒ‘ãƒãƒ«) */
        .sidebar {
            width: 400px; background: var(--panel); border-right: 1px solid var(--border);
            display: flex; flex-direction: column;
        }

        /* ã‚¿ãƒ–åˆ‡ã‚Šæ›¿ãˆ */
        .tabs { display: flex; background: #111; }
        .tab-btn {
            flex: 1; padding: 12px; background: transparent; border: none; color: var(--muted);
            cursor: pointer; border-bottom: 2px solid transparent; font-weight: bold; transition: 0.2s;
        }
        .tab-btn:hover { color: white; background: #222; }
        .tab-btn.active { color: var(--accent); border-bottom-color: var(--accent); background: var(--panel); }

        /* ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚¨ãƒªã‚¢ */
        .scroll-content { flex: 1; overflow-y: auto; padding: 15px; }

        /* ã‚«ãƒ¼ãƒ‰ãƒ‡ã‚¶ã‚¤ãƒ³ */
        .card { background: var(--card); border-radius: 8px; padding: 12px; margin-bottom: 12px; border: 1px solid #444; }
        .card h3 { margin: 0 0 10px 0; font-size: 0.8rem; color: var(--accent); text-transform: uppercase; border-bottom: 1px solid #444; padding-bottom: 5px; display: flex; justify-content: space-between; align-items: center; }

        /* å…¥åŠ›éƒ¨å“ */
        textarea, input[type="text"], input[type="number"] {
            width: 100%; background: #111; border: 1px solid #555; color: white;
            padding: 8px; border-radius: 4px; box-sizing: border-box; font-family: inherit;
        }
        textarea { resize: vertical; height: 60px; font-weight: bold; font-size: 1.2rem; }
        
        .row { display: flex; align-items: center; gap: 8px; margin-top: 8px; }
        .row label { flex: 1; color: var(--muted); font-size: 0.8rem; }
        input[type="range"] { flex: 2; cursor: pointer; height: 6px; border-radius: 3px; accent-color: var(--accent); }
        input[type="checkbox"] { width: 16px; height: 16px; accent-color: var(--accent); }
        input[type="color"] { background: none; border: none; width: 30px; height: 30px; cursor: pointer; padding: 0; }
        select { background: #111; color: white; border: 1px solid #555; padding: 4px; border-radius: 4px; width: 100%; }

        /* è·äººãƒ¢ãƒ¼ãƒ‰ç”¨æ–‡å­—ã‚»ãƒ¬ã‚¯ã‚¿ */
        .char-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(40px, 1fr)); gap: 5px; margin-bottom: 10px; }
        .char-btn {
            aspect-ratio: 1; background: #444; border: 2px solid transparent; color: white;
            font-size: 1.2rem; border-radius: 4px; cursor: pointer; display: flex; align-items: center; justify-content: center;
        }
        .char-btn:hover { background: #555; }
        .char-btn.selected { border-color: var(--accent); background: #3a3c45; }

        /* ãƒ¡ã‚¤ãƒ³ãƒ“ãƒ¥ãƒ¼ (ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼) */
        .main { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 20px; gap: 20px; overflow-y: auto; }
        
        .canvas-wrapper {
            position: relative; padding: 20px;
            background: repeating-conic-gradient(#333 0% 25%, #444 0% 50%) 50% / 20px 20px;
            border: 4px solid var(--panel); border-radius: 12px; box-shadow: 0 10px 40px rgba(0,0,0,0.5);
        }

        .discord-preview { background: #313338; padding: 15px; border-radius: 8px; width: 100%; max-width: 400px; border: 1px solid #444; }
        .msg { display: flex; gap: 10px; }
        .avatar { width: 40px; height: 40px; background: var(--accent); border-radius: 50%; flex-shrink: 0; }
        .preview-img { width: 48px; height: 48px; object-fit: contain; }

        /* ãƒœã‚¿ãƒ³é¡ */
        .btn { border: none; border-radius: 4px; padding: 8px 12px; cursor: pointer; font-weight: bold; color: white; transition: 0.2s; width: 100%; }
        .btn-primary { background: var(--accent); }
        .btn-success { background: var(--success); padding: 15px; font-size: 1.1rem; }
        .btn-danger { background: var(--danger); width: auto; padding: 2px 8px; font-size: 0.8rem; }
        .btn-secondary { background: #4e5058; }
        .btn:hover { opacity: 0.9; transform: translateY(-1px); }

        /* ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆä¿å­˜ã‚¨ãƒªã‚¢ */
        .template-area { display: flex; gap: 5px; margin-top: 10px; }

        /* éè¡¨ç¤ºã‚¯ãƒ©ã‚¹ */
        .hidden { display: none !important; }

    </style>
</head>
<body>

<div class="sidebar">
    <div class="tabs">
        <button class="tab-btn active" onclick="switchTab('simple')">Simple</button>
        <button class="tab-btn" onclick="switchTab('craftsman')">è·äºº (Detail)</button>
        <button class="tab-btn" onclick="switchTab('batch')">ä¸€æ‹¬ (Batch)</button>
    </div>

    <div class="scroll-content" id="panel-content">
        <div class="card">
            <h3>TEXT <button class="btn-danger" style="width:auto;" onclick="resetParams()">Reset</button></h3>
            <textarea id="textInput" placeholder="æ–‡å­—ã‚’å…¥åŠ›">æœ€å¼·&#10;ç„¡æ•µ</textarea>
            <div class="row">
                <select id="fontFamily">
                    <option value="'Dela Gothic One'">Dela Gothic (è¶…æ¥µå¤ª)</option>
                    <option value="'Noto Sans JP'">Noto Sans JP (æ¨™æº–)</option>
                    <option value="'Reggae One'">Reggae One (åŠ‡ç”»é¢¨)</option>
                    <option value="'RocknRoll One'">RocknRoll One (ãƒãƒƒãƒ—)</option>
                    <option value="'M PLUS 2'">M PLUS 2 (ä¸¸æ–‡å­—)</option>
                    <option value="custom">ğŸ“‚ ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ...</option>
                </select>
                <input type="file" id="fontFile" accept=".ttf,.otf,.woff" style="display:none;">
            </div>
        </div>

        <div id="tab-simple" class="tab-pane">
            <div class="card">
                <h3>Global Style</h3>
                <div class="row">
                    <label>ã‚µã‚¤ã‚º</label><input type="range" id="globalSize" min="50" max="250" value="130">
                </div>
                <div class="row">
                    <label>è¡Œé–“</label><input type="range" id="globalLineHeight" min="0.5" max="2.0" step="0.1" value="0.9">
                </div>
                <div class="row">
                    <label>æ–œä½“ (Skew)</label><input type="range" id="globalSkew" min="-45" max="45" value="0">
                </div>
            </div>

            <div class="card">
                <h3>Color & Neon</h3>
                <div class="row">
                    <label>ä¸Šè‰²</label><input type="color" id="col1" value="#FFFFFF">
                    <label>ä¸‹è‰²</label><input type="color" id="col2" value="#FFFF00">
                </div>
                <div class="row">
                    <label>ã‚°ãƒ©ãƒ‡è§’åº¦</label><input type="range" id="gradAngle" min="0" max="360" value="90">
                </div>
                <hr style="border:0; border-top:1px solid #444; margin:10px 0;">
                <div class="row">
                    <label>ãƒã‚ªãƒ³ (Glow)</label><input type="checkbox" id="useNeon">
                    <input type="color" id="neonColor" value="#ff0055">
                </div>
                <div class="row">
                    <label>ç™ºå…‰å¼·åº¦</label><input type="range" id="neonBlur" min="0" max="50" value="20">
                </div>
            </div>

            <div class="card">
                <h3>Strokes (ç¸å–ã‚Š)</h3>
                <div id="strokeList"></div>
                <button class="btn btn-secondary" onclick="addStroke()">+ ãƒ¬ã‚¤ãƒ¤ãƒ¼è¿½åŠ </button>
            </div>
        </div>

        <div id="tab-craftsman" class="tab-pane hidden">
            <div class="card">
                <h3>Character Select</h3>
                <div style="font-size:0.8rem; color:var(--muted); margin-bottom:5px;">ç·¨é›†ã—ãŸã„æ–‡å­—ã‚’ã‚¯ãƒªãƒƒã‚¯</div>
                <div class="char-grid" id="charGrid"></div>
            </div>

            <div class="card" id="charDetailCard" style="opacity:0.5; pointer-events:none;">
                <h3>Transform: <span id="selectedCharLabel">-</span></h3>
                <div class="row">
                    <label>X ç§»å‹•</label><input type="range" id="charX" min="-64" max="64" value="0">
                </div>
                <div class="row">
                    <label>Y ç§»å‹•</label><input type="range" id="charY" min="-64" max="64" value="0">
                </div>
                <div class="row">
                    <label>å›è»¢</label><input type="range" id="charRot" min="-180" max="180" value="0">
                </div>
                <div class="row">
                    <label>æ‹¡å¤§</label><input type="range" id="charScale" min="0.5" max="2.5" step="0.1" value="1">
                </div>
                <div class="row">
                    <label>å€‹åˆ¥è‰²</label>
                    <input type="checkbox" id="charUseColor">
                    <input type="color" id="charCol" value="#ff0000">
                </div>
            </div>
        </div>

        <div id="tab-batch" class="tab-pane hidden">
            <div class="card">
                <h3>Batch Generation</h3>
                <p style="font-size:0.8rem; color:var(--muted);">1è¡Œã«ã¤ã1æšã®ç”»åƒã‚’ç”Ÿæˆã—ã¾ã™ã€‚</p>
                <textarea id="batchInput" style="height:150px; font-size:1rem; font-weight:normal;" placeholder="ç¥&#10;è‰&#10;ä¹™&#10;å°Šã„"></textarea>
                <br><br>
                <button class="btn btn-primary" onclick="runBatch()">ä¸€æ‹¬ç”Ÿæˆã—ã¦ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</button>
            </div>
        </div>
        
        <div class="card">
            <h3>Templates</h3>
            <div class="template-area">
                <button class="btn btn-secondary" onclick="saveTemplate()">ä¿å­˜</button>
                <button class="btn btn-secondary" onclick="loadTemplate()">èª­è¾¼</button>
                <button class="btn btn-danger" onclick="clearTemplate()">å‰Šé™¤</button>
            </div>
        </div>
    </div>
</div>

<div class="main">
    <div class="canvas-wrapper">
        <canvas id="canvas" width="128" height="128"></canvas>
    </div>

    <div class="discord-preview">
        <div style="margin-bottom:5px; font-size:0.8rem; color:var(--muted);">DISCORD PREVIEW (DARK)</div>
        <div class="msg">
            <div class="avatar"></div>
            <div style="flex:1;">
                <div style="font-weight:bold; font-size:0.9rem; margin-bottom:5px;">
                    User <span style="font-weight:normal; color:var(--muted); font-size:0.7rem;">Today 12:34</span>
                </div>
                <img id="previewImg" class="preview-img" src="">
            </div>
        </div>
    </div>

    <button class="btn btn-success" id="dlBtn" style="max-width:300px;">ç”»åƒã‚’ä¿å­˜ (PNG)</button>
</div>

<script>
    // --- State Management ---
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    // ã‚¢ãƒ—ãƒªã®çŠ¶æ…‹
    let state = {
        text: "æœ€å¼·\nç„¡æ•µ",
        font: "'Dela Gothic One'",
        globalSize: 130,
        lineHeight: 0.9,
        skew: 0,
        colors: { top: "#FFFFFF", bottom: "#FFFF00", angle: 90 },
        neon: { enabled: false, color: "#ff0055", blur: 20 },
        strokes: [
            { color: '#000000', width: 6 }, // Inner
            { color: '#FFFFFF', width: 10 } // Outer
        ],
        // è·äººãƒ¢ãƒ¼ãƒ‰ç”¨ã®å€‹åˆ¥è¨­å®š (indexã‚’ã‚­ãƒ¼ã«ã™ã‚‹)
        charStyles: {} 
    };

    let selectedCharIndex = -1; // è·äººãƒ¢ãƒ¼ãƒ‰ã§ã®é¸æŠä¸­æ–‡å­—ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹

    // --- Initialization & Events ---
    function init() {
        renderStrokeUI();
        updateCharGrid();
        draw();

        // Inputs Event Listeners
        document.getElementById('textInput').oninput = (e) => { state.text = e.target.value; updateCharGrid(); draw(); };
        document.getElementById('fontFamily').onchange = (e) => {
            if(e.target.value === 'custom') document.getElementById('fontFile').click();
            else { state.font = e.target.value; draw(); }
        };
        document.getElementById('fontFile').onchange = loadCustomFont;

        // Simple Mode Controls
        bindInput('globalSize', 'globalSize', parseInt);
        bindInput('globalLineHeight', 'lineHeight', parseFloat);
        bindInput('globalSkew', 'skew', parseInt);
        bindInput('col1', 'colors.top');
        bindInput('col2', 'colors.bottom');
        bindInput('gradAngle', 'colors.angle', parseInt);
        bindInput('useNeon', 'neon.enabled', 'checkbox');
        bindInput('neonColor', 'neon.color');
        bindInput('neonBlur', 'neon.blur', parseInt);

        // Craftsman Controls
        document.getElementById('charX').oninput = (e) => updateCharStyle('x', parseInt(e.target.value));
        document.getElementById('charY').oninput = (e) => updateCharStyle('y', parseInt(e.target.value));
        document.getElementById('charRot').oninput = (e) => updateCharStyle('rot', parseInt(e.target.value));
        document.getElementById('charScale').oninput = (e) => updateCharStyle('scale', parseFloat(e.target.value));
        document.getElementById('charUseColor').onchange = (e) => updateCharStyle('useColor', e.target.checked);
        document.getElementById('charCol').oninput = (e) => updateCharStyle('color', e.target.value);

        // Download
        document.getElementById('dlBtn').onclick = () => downloadImage(state.text.replace(/\n/g,'_').substring(0,10));
    }

    // --- Helper: Bind Input to State ---
    function bindInput(id, statePath, type) {
        const el = document.getElementById(id);
        el.addEventListener('input', (e) => {
            let val = type === 'checkbox' ? e.target.checked : (type ? type(e.target.value) : e.target.value);
            // Deep set (e.g. "colors.top")
            const parts = statePath.split('.');
            let target = state;
            for(let i=0; i<parts.length-1; i++) target = target[parts[i]];
            target[parts[parts.length-1]] = val;
            draw();
        });
    }

    // --- Tab Switching ---
    window.switchTab = (mode) => {
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        document.querySelectorAll('.tab-pane').forEach(p => p.classList.add('hidden'));
        
        // Button Activation
        const btnIndex = mode === 'simple' ? 0 : mode === 'craftsman' ? 1 : 2;
        document.querySelectorAll('.tab-btn')[btnIndex].classList.add('active');
        
        document.getElementById(`tab-${mode}`).classList.remove('hidden');
        
        if(mode === 'craftsman') updateCharGrid();
    };

    // --- Craftsman Logic ---
    function updateCharGrid() {
        const grid = document.getElementById('charGrid');
        grid.innerHTML = '';
        const chars = Array.from(state.text.replace(/\n/g, '')); // æ”¹è¡Œé™¤å»ã—ã¦ãƒªã‚¹ãƒˆåŒ–
        
        // æ”¹è¡Œã‚’å«ã‚ãŸãƒãƒƒãƒ”ãƒ³ã‚°ãŒå¿…è¦ã ãŒã€ç°¡å˜ã®ãŸã‚ã€Œè¡¨ç¤ºã•ã‚Œã‚‹æ–‡å­—é †ã€ã§ç®¡ç†
        let displayIndex = 0;
        for(let i=0; i<state.text.length; i++) {
            const char = state.text[i];
            if(char === '\n') continue;
            
            const btn = document.createElement('div');
            btn.className = `char-btn ${selectedCharIndex === displayIndex ? 'selected' : ''}`;
            btn.textContent = char;
            const idx = displayIndex; // closure fix
            btn.onclick = () => selectChar(idx, char);
            grid.appendChild(btn);
            displayIndex++;
        }
    }

    function selectChar(index, char) {
        selectedCharIndex = index;
        updateCharGrid(); // ãƒã‚¤ãƒ©ã‚¤ãƒˆæ›´æ–°
        
        const card = document.getElementById('charDetailCard');
        card.style.opacity = 1;
        card.style.pointerEvents = 'auto';
        document.getElementById('selectedCharLabel').textContent = `ã€Œ${char}ã€`;

        // Load existing styles or defaults
        const s = state.charStyles[index] || { x:0, y:0, rot:0, scale:1, useColor:false, color:'#ff0000' };
        document.getElementById('charX').value = s.x;
        document.getElementById('charY').value = s.y;
        document.getElementById('charRot').value = s.rot;
        document.getElementById('charScale').value = s.scale;
        document.getElementById('charUseColor').checked = s.useColor;
        document.getElementById('charCol').value = s.color;
    }

    function updateCharStyle(key, value) {
        if(selectedCharIndex === -1) return;
        if(!state.charStyles[selectedCharIndex]) {
            state.charStyles[selectedCharIndex] = { x:0, y:0, rot:0, scale:1, useColor:false, color:'#ff0000' };
        }
        state.charStyles[selectedCharIndex][key] = value;
        draw();
    }

    // --- Stroke Management ---
    window.addStroke = () => {
        state.strokes.unshift({ color: '#ffffff', width: 8 }); // å†…å´ã«è¿½åŠ 
        renderStrokeUI(); draw();
    };

    function renderStrokeUI() {
        const list = document.getElementById('strokeList');
        list.innerHTML = '';
        // æç”»é †(å¤–->å†…)ã¨ãƒªã‚¹ãƒˆè¡¨ç¤º(å†…->å¤–)ã®UXæ•´åˆæ€§
        // ã“ã“ã§ã¯é…åˆ—[0]ãŒå†…å´ã€é…åˆ—[N]ãŒå¤–å´ã¨ã—ã¦ç®¡ç†ã—ã€æç”»æ™‚ã«é€†é †ãƒ«ãƒ¼ãƒ—ã™ã‚‹
        state.strokes.forEach((s, i) => {
            const div = document.createElement('div');
            div.style.cssText = "display:flex; gap:5px; margin-bottom:5px; align-items:center; background:#222; padding:5px; border-radius:4px;";
            div.innerHTML = `
                <span style="font-size:0.7rem; color:#aaa; width:15px;">#${i+1}</span>
                <input type="color" value="${s.color}" oninput="updateStroke(${i}, 'color', this.value)">
                <input type="range" min="0" max="40" value="${s.width}" oninput="updateStroke(${i}, 'width', parseInt(this.value))">
                <button class="btn-danger" onclick="removeStroke(${i})">Ã—</button>
            `;
            list.appendChild(div);
        });
    }
    window.updateStroke = (i, k, v) => { state.strokes[i][k] = v; draw(); };
    window.removeStroke = (i) => { state.strokes.splice(i, 1); renderStrokeUI(); draw(); };

    // --- Custom Font ---
    function loadCustomFont(e) {
        const file = e.target.files[0];
        if(!file) return;
        const reader = new FileReader();
        reader.onload = (ev) => {
            const f = new FontFace('CustomFont', ev.target.result);
            f.load().then(loaded => {
                document.fonts.add(loaded);
                const sel = document.getElementById('fontFamily');
                sel.options[sel.options.length-1].text = `ğŸ“‚ ${file.name}`;
                sel.value = 'custom';
                state.font = 'CustomFont';
                draw();
            });
        };
        reader.readAsArrayBuffer(file);
    }

    // --- Drawing Core (The Magic) ---
    function draw() {
        ctx.clearRect(0, 0, 128, 128);
        const lines = state.text.split('\n');
        
        ctx.font = `900 ${state.globalSize}px ${state.font}`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.lineJoin = 'round';
        ctx.miterLimit = 2;

        // --- Step 1: Layout Calculation (Auto-Fit) ---
        // è·äººãƒ¢ãƒ¼ãƒ‰ã®å€‹åˆ¥å¤‰å½¢ã‚‚å«ã‚ãŸãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹ã‚’è¨ˆç®—ã™ã‚‹ã®ã¯è¤‡é›‘ã™ãã‚‹ãŸã‚ã€
        // ã€Œæ¨™æº–é…ç½®æ™‚ã®ã‚µã‚¤ã‚ºã€ã‚’ãƒ™ãƒ¼ã‚¹ã«ã‚¹ã‚±ãƒ¼ãƒ«ã‚’æ±ºå®šã™ã‚‹ç°¡æ˜“ã‹ã¤å¼·åŠ›ãªã‚¢ãƒ—ãƒ­ãƒ¼ãƒã‚’ã¨ã‚‹
        let maxWidth = 0;
        lines.forEach(l => {
            const m = ctx.measureText(l);
            // æ–œä½“(Skew)ãŒã‚ã‚‹å ´åˆã€å¹…ãŒåºƒãŒã‚‹
            const skewRad = Math.abs(state.skew * Math.PI / 180);
            const skewWidth = state.globalSize * Math.tan(skewRad); 
            if(m.width + skewWidth > maxWidth) maxWidth = m.width + skewWidth;
        });

        const totalStrokeW = state.strokes.reduce((a,b) => a+b.width, 0);
        // ãƒã‚ªãƒ³ã®ã¼ã‹ã—åˆ†ã‚‚è€ƒæ…®
        const neonPadding = state.neon.enabled ? state.neon.blur * 2 : 0;
        
        const contentW = maxWidth + (totalStrokeW * 2) + neonPadding;
        const contentH = (lines.length * state.globalSize * state.lineHeight) + (totalStrokeW * 2) + neonPadding;

        // 128px (Discord max) ã«å¯¾ã—ã¦ã€å°‘ã—ä½™ç™½(120px)ã‚’æŒãŸã›ã¦åã‚ã‚‹
        const scale = Math.min(120 / contentW, 120 / contentH, 1.0);

        // --- Step 2: Render ---
        ctx.save();
        ctx.translate(64, 64);
        ctx.scale(scale, scale);

        // ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®ä¸­å¿ƒãŒ(0,0)ã«æ¥ã‚‹ã‚ˆã†ã«èª¿æ•´
        const totalBlockH = lines.length * state.globalSize * state.lineHeight;
        const startY = -(totalBlockH / 2) + (state.globalSize * state.lineHeight / 2);

        // æç”»ãƒ«ãƒ¼ãƒ—é–¢æ•°
        // layer: 'neon', 'stroke', 'fill'
        // strokeIdx: ç¸å–ã‚Šã®éšå±¤
        const renderLayer = (layer, strokeIdx = -1) => {
            let charIndexCounter = 0;

            lines.forEach((line, lineIdx) => {
                const chars = Array.from(line);
                const lineWidth = ctx.measureText(line).width;
                // è¡Œã”ã¨ã®Xé–‹å§‹ä½ç½® (ä¸­å¤®æƒãˆ)
                let currentX = -lineWidth / 2; 
                // å€‹åˆ¥æ–‡å­—ã®ã‚«ãƒ¼ãƒ‹ãƒ³ã‚°ç­‰ã¯è€ƒæ…®ã›ãšã€measureTextã®å¹…ã§é€ã‚‹ç°¡æ˜“å®Ÿè£…
                // ãŸã ã—ã€è·äººãƒ¢ãƒ¼ãƒ‰å¤‰å½¢ã¯é©ç”¨ã™ã‚‹

                chars.forEach((char, cIdx) => {
                    const charW = ctx.measureText(char).width;
                    const centerX = currentX + charW / 2;
                    const centerY = startY + (lineIdx * state.globalSize * state.lineHeight);

                    // è·äººãƒ¢ãƒ¼ãƒ‰è¨­å®šã®å–å¾—
                    const s = state.charStyles[charIndexCounter] || { x:0, y:0, rot:0, scale:1 };
                    
                    ctx.save();
                    // 1. ä½ç½®ç§»å‹• (Base + Manual)
                    ctx.translate(centerX + s.x, centerY + s.y);
                    
                    // 2. å›è»¢
                    ctx.rotate(s.rot * Math.PI / 180);
                    
                    // 3. æ‹¡å¤§ç¸®å°
                    ctx.scale(s.scale, s.scale);

                    // 4. æ–œä½“ (Skew)
                    if(state.skew !== 0) {
                        ctx.transform(1, 0, Math.tan(state.skew * Math.PI/180), 1, 0, 0);
                    }

                    // æç”»å®Ÿè¡Œ
                    if (layer === 'neon') {
                        ctx.shadowColor = state.neon.color;
                        ctx.shadowBlur = state.neon.blur;
                        ctx.shadowOffsetX = 0; ctx.shadowOffsetY = 0;
                        ctx.fillStyle = state.neon.color;
                        ctx.fillText(char, 0, 0);
                        // ãƒã‚ªãƒ³ã‚’æ¿ƒãã™ã‚‹ãŸã‚ã«é‡ã­ã‚‹
                        ctx.fillText(char, 0, 0);
                    } 
                    else if (layer === 'stroke') {
                        // ç´¯ç©å¹…ã‚’è¨ˆç®— (strokeIdxä»¥ä¸‹ã®å¹…ã®åˆè¨ˆ)
                        // strokesé…åˆ—: [0:Inner ... N:Outer]
                        // æç”»ã¯Outerã‹ã‚‰è¡Œã†ã®ã§ã€strokeIdxã¯ N -> 0 ã¨æ¥ã‚‹
                        let widthSum = 0;
                        for(let k=0; k<=strokeIdx; k++) widthSum += state.strokes[k].width;
                        
                        ctx.strokeStyle = state.strokes[strokeIdx].color;
                        ctx.lineWidth = widthSum * 2;
                        ctx.shadowColor = 'transparent'; // Reset shadow
                        ctx.strokeText(char, 0, 0);
                    }
                    else if (layer === 'fill') {
                        ctx.shadowColor = 'transparent';
                        if (s.useColor && s.color) {
                            ctx.fillStyle = s.color;
                        } else {
                            // Global Gradient
                            // æ–‡å­—å˜ä½ã§ã¯ãªãå…¨ä½“ã«å¯¾ã™ã‚‹ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã«è¦‹ã›ã‚‹ã«ã¯
                            // åº§æ¨™å¤‰æ›ã‚’è€ƒæ…®ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ãŒã€ã“ã“ã§ã¯ã€Œæ–‡å­—ã”ã¨ã€ã«ã‹ã‘ã‚‹
                            const grad = ctx.createLinearGradient(0, -state.globalSize/2, 0, state.globalSize/2);
                            // è§’åº¦å¯¾å¿œã¯å°‘ã—è¤‡é›‘ã«ãªã‚‹ãŸã‚ã€ç°¡æ˜“çš„ã«ç¸¦ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ + è§’åº¦æŒ‡å®šãŒã‚ã‚Œã°å›è»¢
                            // Canvas Gradientã¯åº§æ¨™å›ºå®šãªã®ã§ã€è§’åº¦ã‚’å¤‰ãˆã‚‹ã«ã¯Gradientåº§æ¨™ã‚’å›ã™å¿…è¦ãŒã‚ã‚‹
                            // ã“ã“ã§ã¯ç°¡æ˜“å®Ÿè£…ã¨ã—ã¦Verticalã®ã¿
                            grad.addColorStop(0, state.colors.top);
                            grad.addColorStop(1, state.colors.bottom);
                            ctx.fillStyle = grad;
                        }
                        ctx.fillText(char, 0, 0);
                    }

                    ctx.restore();
                    
                    currentX += charW;
                    charIndexCounter++;
                });
            });
        };

        // ãƒ¬ã‚¤ãƒ¤ãƒ¼é †åºå®Ÿè¡Œ
        // 1. Neon (æœ€èƒŒé¢)
        if(state.neon.enabled) {
            ctx.save();
            renderLayer('neon');
            ctx.restore();
        }

        // 2. Strokes (å¤–å´ã‹ã‚‰é †ã«)
        // state.strokes = [Inner, ..., Outer]
        // Loop: Outer(len-1) -> Inner(0)
        for(let i = state.strokes.length - 1; i >= 0; i--) {
            renderLayer('stroke', i);
        }

        // 3. Fill (æœ€å‰é¢)
        renderLayer('fill');

        ctx.restore();
        
        // Update Preview
        document.getElementById('previewImg').src = canvas.toDataURL();
    }

    // --- Templates & Reset ---
    function saveTemplate() {
        localStorage.setItem('emojiParams', JSON.stringify(state));
        alert('è¨­å®šã‚’ä¿å­˜ã—ã¾ã—ãŸ');
    }
    function loadTemplate() {
        const d = localStorage.getItem('emojiParams');
        if(d) {
            state = JSON.parse(d);
            // UIã¸ã®åæ˜  (ç°¡æ˜“ãƒªãƒ­ãƒ¼ãƒ‰)
            location.reload(); // æœ¬å½“ã¯å„Inputã¸å€¤ã‚’æˆ»ã™ã¹ãã ãŒã€ã‚³ãƒ¼ãƒ‰é‡ç¯€ç´„ã®ãŸã‚ãƒªãƒ­ãƒ¼ãƒ‰ã§åˆæœŸåŒ–ãƒ«ãƒ¼ãƒãƒ³ã‚’é€šã™
        }
    }
    function clearTemplate() {
        localStorage.removeItem('emojiParams');
        alert('ä¿å­˜è¨­å®šã‚’å‰Šé™¤ã—ã¾ã—ãŸ');
    }
    function resetParams() {
        if(confirm('è¨­å®šã‚’åˆæœŸåŒ–ã—ã¾ã™ã‹ï¼Ÿ')) location.reload();
    }

    // --- Batch Generation ---
    async function runBatch() {
        const textRaw = document.getElementById('batchInput').value;
        const lines = textRaw.split('\n').filter(l => l.trim() !== "");
        if(lines.length === 0) return;

        // ç¾åœ¨ã®çŠ¶æ…‹ã‚’ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—
        const originalText = state.text;

        for (let t of lines) {
            state.text = t;
            draw();
            await new Promise(r => setTimeout(r, 200)); // æç”»å¾…ã¡
            downloadImage(t);
        }

        // æˆ»ã™
        state.text = originalText;
        draw();
    }

    function downloadImage(name) {
        const a = document.createElement('a');
        a.href = canvas.toDataURL('image/png');
        a.download = (name || 'emoji') + '.png';
        a.click();
    }

    // Load template on start if exists? No, let user choose.
    window.onload = () => {
        // ã‚‚ã—LocalStorageã«ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Œã°èª­ã¿è¾¼ã‚€ã‹å°‹ã­ã‚‹ãƒ­ã‚¸ãƒƒã‚¯ã‚’å…¥ã‚Œã¦ã‚‚ã„ã„ãŒã€
        // ä»Šå›ã¯è‡ªå‹•èª­è¾¼ã›ãšåˆæœŸåŒ–
        init();
    };

</script>
</body>
</html>
