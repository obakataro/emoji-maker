<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Discord Emoji Ultimate Fixed</title>
    <link href="https://fonts.googleapis.com/css2?family=M+PLUS+2:wght@900&family=Noto+Sans+JP:wght@900&family=Reggae+One&family=RocknRoll+One&family=Dela+Gothic+One&family=Yuji+Syuku:wght@900&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #1e1f22; --panel: #2b2d31; --card: #313338;
            --accent: #5865f2; --success: #248046; --danger: #ed4245; 
            --text: #f2f3f5; --muted: #b5bac1;
        }
        body { font-family: 'Noto Sans JP', sans-serif; background: var(--bg); color: var(--text); margin: 0; display: flex; height: 100vh; overflow: hidden; font-size: 13px; }
        
        /* Layout */
        .sidebar { width: 380px; background: var(--panel); border-right: 1px solid #111; display: flex; flex-direction: column; }
        .main { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; background: #0f0f11; position: relative; }

        /* Tabs */
        .tabs { display: flex; background: #000; }
        .tab-btn { flex: 1; padding: 12px; background: transparent; border: none; color: var(--muted); cursor: pointer; border-bottom: 3px solid transparent; font-weight: bold; }
        .tab-btn.active { color: var(--accent); border-bottom-color: var(--accent); background: var(--panel); }

        .scroll-content { flex: 1; overflow-y: auto; padding: 15px; }
        .card { background: var(--card); border-radius: 8px; padding: 12px; margin-bottom: 12px; border: 1px solid #444; }
        .card h3 { margin: 0 0 10px 0; font-size: 0.75rem; color: var(--accent); text-transform: uppercase; display: flex; justify-content: space-between; }
        
        .row { display: flex; align-items: center; gap: 8px; margin-top: 8px; }
        .row label { flex: 1; color: var(--muted); font-size: 0.8rem; }
        
        input, select, textarea { background: #111; border: 1px solid #555; color: white; border-radius: 4px; padding: 5px; }
        input[type="range"] { flex: 2; accent-color: var(--accent); }
        textarea { width: 100%; box-sizing: border-box; font-size: 1.2rem; font-weight: bold; }

        /* Canvas Area */
        .canvas-container { position: relative; padding: 20px; background: repeating-conic-gradient(#333 0% 25%, #444 0% 50%) 50% / 20px 20px; border: 4px solid var(--panel); border-radius: 12px; }
        .canvas-container.craft-active { outline: 3px solid var(--accent); cursor: crosshair; }
        
        .preview-box { margin-top: 20px; background: #313338; padding: 15px; border-radius: 8px; width: 300px; display: flex; gap: 12px; border: 1px solid #444; }
        .avatar { width: 40px; height: 40px; background: var(--accent); border-radius: 50%; }

        /* Utils */
        .btn { width: 100%; padding: 10px; border: none; border-radius: 4px; cursor: pointer; font-weight: bold; color: white; margin-top: 5px; }
        .btn-green { background: var(--success); }
        .btn-gray { background: #4e5058; }
        .btn-red { background: var(--danger); width: auto; padding: 2px 8px; font-size: 0.7rem; }
        .hidden { display: none !important; }
        
        .char-grid { display: flex; gap: 5px; flex-wrap: wrap; margin-bottom: 10px; }
        .char-btn { width: 35px; height: 35px; background: #444; border: 2px solid transparent; color: white; display: flex; align-items: center; justify-content: center; border-radius: 4px; cursor: pointer; }
        .char-btn.selected { border-color: var(--accent); background: #555; }
    </style>
</head>
<body>

<div class="sidebar">
    <div class="tabs">
        <button class="tab-btn active" onclick="switchTab('main')">Âü∫Êú¨</button>
        <button class="tab-btn" onclick="switchTab('craft')">ËÅ∑‰∫∫</button>
        <button class="tab-btn" onclick="switchTab('batch')">‰∏ÄÊã¨</button>
    </div>

    <div class="scroll-content">
        <div class="card">
            <h3>TEXT <button class="btn-red" onclick="location.reload()">Reset</button></h3>
            <textarea id="textInput" oninput="updateAll()">ÊúÄÂº∑&#10;ÁµµÊñáÂ≠ó</textarea>
            <div class="row">
                <select id="fontFamily" onchange="updateAll()">
                    <option value="'Dela Gothic One'">Dela Gothic (Ê•µÂ§™)</option>
                    <option value="'Noto Sans JP'">Noto Sans JP</option>
                    <option value="'Reggae One'">Reggae One</option>
                    <option value="'RocknRoll One'">RocknRoll One</option>
                    <option value="'Yuji Syuku'">Yuji Syuku (ÊòéÊúù)</option>
                </select>
                <input type="file" id="fontFile" style="display:none" onchange="loadCustomFont(this)">
                <button class="btn-gray" onclick="document.getElementById('fontFile').click()" style="width:60px; font-size:0.7rem;">üìÇ„Éï„Ç©„É≥„Éà</button>
            </div>
        </div>

        <div id="tab-main">
            <div class="card">
                <h3>Style</h3>
                <div class="row"><label>„Çµ„Ç§„Ç∫</label><input type="range" id="globalSize" min="50" max="250" value="120" oninput="updateAll()"></div>
                <div class="row"><label>Ë°åÈñì</label><input type="range" id="lineHeight" min="0.5" max="1.5" step="0.05" value="0.85" oninput="updateAll()"></div>
                <div class="row">
                    <label>‰∏äËâ≤</label><input type="color" id="col1" value="#FFFFFF" oninput="updateAll()">
                    <label>‰∏ãËâ≤</label><input type="color" id="col2" value="#00d4ff" oninput="updateAll()">
                </div>
            </div>
            <div class="card">
                <h3>Strokes</h3>
                <div id="strokeList"></div>
                <button class="btn btn-gray" onclick="addStroke()">+ Á∏ÅÂèñ„ÇäËøΩÂä†</button>
            </div>
            <div class="card">
                <h3>Special</h3>
                <div class="row"><label>Êñú‰Ωì</label><input type="range" id="skew" min="-40" max="40" value="0" oninput="updateAll()"></div>
                <div class="row"><label>„Éç„Ç™„É≥</label><input type="checkbox" id="useNeon" onchange="updateAll()"> <input type="color" id="neonColor" value="#5865f2" oninput="updateAll()"></div>
                <div class="row"><label>Ë≥™ÊÑü</label>
                    <select id="texture" onchange="updateAll()">
                        <option value="none">„Å™„Åó</option>
                        <option value="noise">„Ç∂„É©„Ç∂„É©</option>
                        <option value="gloss">ÂÖâÊ≤¢</option>
                    </select>
                </div>
            </div>
        </div>

        <div id="tab-craft" class="hidden">
            <div class="card">
                <h3>ËÅ∑‰∫∫„É¢„Éº„Éâ</h3>
                <p style="font-size:0.7rem; color:var(--muted);">„Ç≠„É£„É≥„Éê„Çπ‰∏ä„ÅÆÊñáÂ≠ó„ÇíÁõ¥Êé•„Éâ„É©„ÉÉ„Ç∞„Åß„Åç„Åæ„Åô„ÄÇ</p>
                <div class="char-grid" id="charGrid"></div>
                <button class="btn btn-gray" onclick="copyFirstToAll()">1ÊñáÂ≠óÁõÆ„ÅÆË®≠ÂÆö„ÇíÂÖ®ÈÅ©Áî®</button>
            </div>
            <div id="charDetail" class="card" style="opacity:0.5; pointer-events:none;">
                <h3 id="selectedCharLabel">ÂÄãÂà•Ë®≠ÂÆö</h3>
                <div class="row"><label>ÂõûËª¢</label><input type="range" id="c_rot" min="-180" max="180" value="0" oninput="updateCharProp()"></div>
                <div class="row"><label>Êã°Â§ß</label><input type="range" id="c_scale" min="0.5" max="2.5" step="0.1" value="1" oninput="updateCharProp()"></div>
                <div class="row"><label>ÂÄãÂà•Ëâ≤</label><input type="checkbox" id="c_useCol" onchange="updateCharProp()"> <input type="color" id="c_col" value="#ff0000" oninput="updateCharProp()"></div>
            </div>
        </div>

        <div id="tab-batch" class="hidden">
            <div class="card">
                <h3>‰∏ÄÊã¨ÁîüÊàê</h3>
                <textarea id="batchInput" style="height:120px; font-size:1rem;" placeholder="1Ë°å„Åö„Å§ÂÖ•Âäõ&#10;Á•û&#10;Ëçâ&#10;ÊúÄÂº∑"></textarea>
                <button class="btn btn-green" onclick="runBatch()">‰∏ÄÊã¨„ÉÄ„Ç¶„É≥„É≠„Éº„ÉâÈñãÂßã</button>
            </div>
        </div>

        <div class="card">
            <h3>Template</h3>
            <div class="row">
                <button class="btn btn-gray" onclick="saveTemplate()">‰øùÂ≠ò</button>
                <button class="btn btn-gray" onclick="loadTemplate()">Ë™≠Ëæº</button>
            </div>
        </div>
    </div>
</div>

<div class="main">
    <div id="canvasWrapper" class="canvas-container">
        <canvas id="canvas" width="128" height="128"></canvas>
    </div>
    
    <div class="preview-box">
        <div class="avatar"></div>
        <div>
            <div style="font-weight:bold; font-size:0.9rem;">Preview <span style="font-weight:normal; color:#aaa; font-size:0.7rem;">Today at 12:00</span></div>
            <img id="previewImg" style="width:48px; height:48px; object-fit:contain; margin-top:5px;">
        </div>
    </div>

    <button class="btn btn-green" style="width:300px; margin-top:20px;" onclick="downloadSingle()">PNG„Çí‰øùÂ≠ò</button>
</div>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let strokes = [{color:'#000000', width:6}, {color:'#ffffff', width:10}];
    let charStyles = [];
    let selectedIdx = -1;
    let dragInfo = { active: false, idx: -1, startX: 0, startY: 0 };

    // --- Core Logic ---
    function updateAll() {
        // „Éï„Ç©„É≥„Éà„ÅåË™≠„ÅøËæº„Åæ„Çå„Çã„ÅÆ„ÇíÂæÖ„Å£„Å¶„Åã„ÇâÊèèÁîª
        document.fonts.ready.then(() => draw());
    }

    function draw() {
        ctx.clearRect(0, 0, 128, 128);
        const text = document.getElementById('textInput').value;
        const lines = text.split('\n');
        const fontSize = parseInt(document.getElementById('globalSize').value);
        const font = document.getElementById('fontFamily').value;
        const lh = parseFloat(document.getElementById('lineHeight').value);
        const skew = parseInt(document.getElementById('skew').value) * Math.PI / 180;

        ctx.font = `900 ${fontSize}px ${font}`;
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.lineJoin = 'round';

        // Get max width for auto-scale
        let maxW = 0;
        lines.forEach(l => {
            const w = ctx.measureText(l).width + Math.abs(fontSize * Math.tan(skew));
            if(w > maxW) maxW = w;
        });

        const strokePadding = strokes.reduce((a, b) => a + b.width, 0) * 2;
        const scale = Math.min(120 / (maxW + strokePadding), 120 / (lines.length * fontSize * lh + strokePadding), 1.0);

        ctx.save();
        ctx.translate(64, 64);
        ctx.scale(scale, scale);

        const drawText = (mode, sIdx) => {
            let cCount = 0;
            lines.forEach((line, li) => {
                const chars = Array.from(line);
                const lineW = ctx.measureText(line).width;
                let curX = -lineW / 2;
                const curY = (li - (lines.length - 1) / 2) * (fontSize * lh);

                chars.forEach(char => {
                    const cw = ctx.measureText(char).width;
                    const style = charStyles[cCount] || {x:0, y:0, rot:0, scale:1};
                    
                    ctx.save();
                    ctx.translate(curX + cw/2 + (style.x||0), curY + (style.y||0));
                    ctx.transform(1, 0, Math.tan(skew), 1, 0, 0);
                    ctx.rotate((style.rot||0) * Math.PI / 180);
                    ctx.scale(style.scale||1, style.scale||1);

                    if(mode === 'neon' && document.getElementById('useNeon').checked) {
                        ctx.shadowColor = document.getElementById('neonColor').value;
                        ctx.shadowBlur = 15;
                        ctx.fillStyle = ctx.shadowColor;
                        ctx.fillText(char, 0, 0);
                    } else if(mode === 'stroke') {
                        let totalW = 0;
                        for(let i=0; i<=sIdx; i++) totalW += strokes[i].width;
                        ctx.strokeStyle = strokes[sIdx].color;
                        ctx.lineWidth = totalW * 2;
                        ctx.strokeText(char, 0, 0);
                    } else if(mode === 'fill') {
                        if(style.useCol) {
                            ctx.fillStyle = style.col;
                        } else {
                            const grad = ctx.createLinearGradient(0, -fontSize/2, 0, fontSize/2);
                            grad.addColorStop(0, document.getElementById('col1').value);
                            grad.addColorStop(1, document.getElementById('col2').value);
                            ctx.fillStyle = grad;
                        }
                        ctx.fillText(char, 0, 0);
                    }
                    ctx.restore();
                    curX += cw;
                    cCount++;
                });
            });
        };

        if(document.getElementById('useNeon').checked) drawText('neon');
        for(let i=strokes.length-1; i>=0; i--) drawText('stroke', i);
        drawText('fill');
        ctx.restore();

        // Texture
        const tex = document.getElementById('texture').value;
        if(tex !== 'none') {
            ctx.save(); ctx.globalCompositeOperation = 'source-atop'; ctx.globalAlpha = 0.3;
            if(tex === 'noise') {
                for(let i=0; i<1000; i++) { ctx.fillStyle=Math.random()>0.5?'#fff':'#000'; ctx.fillRect(Math.random()*128, Math.random()*128, 1, 1); }
            } else {
                const g = ctx.createLinearGradient(0,0,128,128); g.addColorStop(0,'#fff'); g.addColorStop(1,'transparent');
                ctx.fillStyle=g; ctx.fillRect(0,0,128,128);
            }
            ctx.restore();
        }

        document.getElementById('previewImg').src = canvas.toDataURL();
    }

    // --- UI/Interactions ---
    function switchTab(t) {
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        event.target.classList.add('active');
        ['main', 'craft', 'batch'].forEach(id => document.getElementById('tab-'+id).classList.add('hidden'));
        document.getElementById('tab-'+t).classList.remove('hidden');
        document.getElementById('canvasWrapper').className = 'canvas-container' + (t==='craft'?' craft-active':'');
        if(t === 'craft') refreshCharGrid();
    }

    function refreshCharGrid() {
        const grid = document.getElementById('charGrid'); grid.innerHTML = '';
        const chars = Array.from(document.getElementById('textInput').value.replace(/\n/g,''));
        chars.forEach((c, i) => {
            const b = document.createElement('div'); b.className = 'char-btn' + (selectedIdx===i?' selected':'');
            b.innerText = c; b.onclick = () => selectChar(i);
            grid.appendChild(b);
        });
    }

    function selectChar(i) {
        selectedIdx = i; refreshCharGrid();
        const d = document.getElementById('charDetail'); d.style.opacity = 1; d.style.pointerEvents = 'auto';
        const s = charStyles[i] || {rot:0, scale:1, useCol:false, col:'#ff0000'};
        document.getElementById('c_rot').value = s.rot;
        document.getElementById('c_scale').value = s.scale;
        document.getElementById('c_useCol').checked = s.useCol;
        document.getElementById('c_col').value = s.col;
    }

    function updateCharProp() {
        if(selectedIdx < 0) return;
        charStyles[selectedIdx] = {
            x: charStyles[selectedIdx]?.x || 0, y: charStyles[selectedIdx]?.y || 0,
            rot: parseInt(document.getElementById('c_rot').value),
            scale: parseFloat(document.getElementById('c_scale').value),
            useCol: document.getElementById('c_useCol').checked,
            col: document.getElementById('c_col').value
        };
        draw();
    }

    // --- Drag Logic ---
    canvas.onmousedown = (e) => {
        if(!document.getElementById('canvasWrapper').classList.contains('craft-active')) return;
        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left) * (128 / rect.width);
        const y = (e.clientY - rect.top) * (128 / rect.height);
        // Find closest char (simplified)
        dragInfo = { active: true, idx: selectedIdx >= 0 ? selectedIdx : 0, startX: x, startY: y };
    };
    window.onmousemove = (e) => {
        if(!dragInfo.active) return;
        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left) * (128 / rect.width);
        const y = (e.clientY - rect.top) * (128 / rect.height);
        if(!charStyles[dragInfo.idx]) charStyles[dragInfo.idx] = {x:0, y:0, rot:0, scale:1};
        charStyles[dragInfo.idx].x += (x - dragInfo.startX);
        charStyles[dragInfo.idx].y += (y - dragInfo.startY);
        dragInfo.startX = x; dragInfo.startY = y;
        draw();
    };
    window.onmouseup = () => dragInfo.active = false;

    // --- Batch/Template ---
    async function runBatch() {
        const words = document.getElementById('batchInput').value.split('\n').filter(w => w.trim());
        const originalText = document.getElementById('textInput').value;
        for(let word of words) {
            document.getElementById('textInput').value = word;
            draw();
            await new Promise(r => setTimeout(r, 300));
            const link = document.createElement('a');
            link.download = `emoji_${word}.png`; link.href = canvas.toDataURL(); link.click();
        }
        document.getElementById('textInput').value = originalText; draw();
    }

    function downloadSingle() {
        const link = document.createElement('a');
        link.download = 'emoji.png'; link.href = canvas.toDataURL(); link.click();
    }

    function addStroke() {
        strokes.unshift({color:'#ffffff', width:5}); renderStrokes(); draw();
    }

    function renderStrokes() {
        const list = document.getElementById('strokeList'); list.innerHTML = '';
        strokes.forEach((s, i) => {
            const d = document.createElement('div'); d.className = 'row'; d.style.background='#222'; d.style.padding='4px';
            d.innerHTML = `<input type="color" value="${s.color}" oninput="strokes[${i}].color=this.value; draw()">
                           <input type="range" max="30" value="${s.width}" oninput="strokes[${i}].width=parseInt(this.value); draw()">
                           <button class="btn-red" onclick="strokes.splice(${i},1); renderStrokes(); draw()">√ó</button>`;
            list.appendChild(d);
        });
    }

    function loadCustomFont(input) {
        const file = input.files[0];
        const reader = new FileReader();
        reader.onload = (e) => {
            const f = new FontFace('CustomFont', e.target.result);
            f.load().then(loaded => {
                document.fonts.add(loaded);
                const sel = document.getElementById('fontFamily');
                sel.innerHTML = `<option value="CustomFont">üìÇ ${file.name}</option>` + sel.innerHTML;
                sel.value = "CustomFont"; draw();
            });
        };
        reader.readAsArrayBuffer(file);
    }

    function saveTemplate() {
        const data = { strokes, charStyles, config: {
            size: document.getElementById('globalSize').value,
            col1: document.getElementById('col1').value,
            col2: document.getElementById('col2').value,
            skew: document.getElementById('skew').value
        }};
        localStorage.setItem('emoji_temp', JSON.stringify(data));
        alert("‰øùÂ≠ò„Åó„Åæ„Åó„Åü");
    }

    function loadTemplate() {
        const data = JSON.parse(localStorage.getItem('emoji_temp'));
        if(!data) return;
        strokes = data.strokes; charStyles = data.charStyles;
        document.getElementById('globalSize').value = data.config.size;
        document.getElementById('col1').value = data.config.col1;
        document.getElementById('col2').value = data.config.col2;
        document.getElementById('skew').value = data.config.skew;
        renderStrokes(); draw();
    }

    window.onload = () => { renderStrokes(); updateAll(); };
</script>
</body>
</html>

